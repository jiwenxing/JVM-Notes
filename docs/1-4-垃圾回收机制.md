GC（垃圾收集）是一个早于 Java 的概念，诞生于1960年的 Lisp 语言当时就使用了内存动态分配和垃圾收集技术，经过半个世纪发展，这项技术已经发展很成熟。之所以还要去探究 GC 和内存分配，是因为当程序万一出现了内存溢出、内存泄漏等问题的时候，当垃圾收集称为系统高并发性能瓶颈的时候，我们需要有针对性的对 JVM 自动化的内存分配和垃圾回收策略实施必要的监控和调整。



要学习 GC 必须思考以下三个问题：

- 哪些内存需要回收
- 什么时候回收
- 怎么回收



## 哪些内存需要回收

通过前面的介绍，我们知道 JVM 管理的内存中，线程私有的虚拟机栈、本地方法栈以及程序计数器都是随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊的进行入栈和出栈。这部分内存区域随着线程结束或者方法退出自然的就被释放回收了，因此这部分不需要过多考虑回收问题。而 Java 堆及方法区则不一样，这部分内存的分配和回收都是动态的。垃圾收集器关注的区域主要指的是这部分内存。

### 判断对象是否存活的方法

GC  在垃圾回收的时候首先需要判断哪些对象时“存活”的，哪些是已经“死亡”了（不能够再被使用到的对象）可以回收，判断的方法主要有 **引用计数法** 及 **可达性分析法**。

**引用计数法：** 给对象添加一个引用计数器，每当有一个地方引用计数器就加1，引用失效时计数器就减1，因此哪些计数器为0的对象都是不再被引用需要回收的对象。优点是实现简单、效率也高，但是缺点就是无法解决对象之间相互引用的情况。

**可达性分析法（HotSpot 默认）：** 通过一系列称为 **GC Roots** 的对象作为起点开始向下进行搜索，搜索走过的路径叫做引用链，如果一个对象没有任何引用链与其相连时说明该对象不可达，即不可能再被使用到，这时便被判定为可回收的对象。在 Java 中 **可作为 GC Roots 的对象**有以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中 Native 方法引用的对象
- 方法区中的常量引用的对象

需要注意的一点是在可达性分析方中不可达的对象也并非就一定是“非死不可”的，GC 在第一次可达性分析发现对象不可达时进行一次标记，同时会判断该对象是否有必要执行 **finalize()** 方法（当对象覆盖了finalize()方法并且没有被调用过时才会被认为有必要），如果判断有必要则将其加入一个叫作 **F-Queue** 的队列，稍后虚拟机会启动一个专门的、低优先级的线程去依次执行队列中对象的 finalize 方法，并且不保证一定执行成功。在对象的 finalize 方法中如果对象将自己（this关键字）与引用链上的任意对象建立关联，那么在下一次可达性标记的时候这个对象就会被从“即将回收”的集合中移除。代码举例见p67。注意 **finalize()** 方法不被建议在代码中使用，因为其能做的事情 **try-finally** 都能够做的更好！

